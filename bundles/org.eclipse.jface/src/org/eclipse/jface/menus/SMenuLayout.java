/******************************************************************************* * Copyright (c) 2006 IBM Corporation and others. * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: *     IBM Corporation - initial API and implementation ******************************************************************************/package org.eclipse.jface.menus;import java.util.Collection;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import org.eclipse.core.commands.common.NotDefinedException;/** * <p> * The layout of various menu elements. A layout includes all menus, groups, * items and widgets -- regardless of whether they are currently visible. * </p> * <p> * There are three basic types of menu elements: part, popup and bar. Each of * these fundamental types has a map of subelements -- indexed by some string. * </p> * <p> * Clients may instantiate, but must not extend. * </p> * <p> * <strong>EXPERIMENTAL</strong>. This class or interface has been added as * part of a work in progress. There is a guarantee neither that this API will * work nor that it will remain the same. Please do not use this API without * consulting with the Platform/UI team. * </p> *  * @since 3.2 */public final class SMenuLayout {	static final SMenuLayout computeLayout(final Collection menuElements) {		final Map[] bars = new Map[SBar.NUMBER_OF_TYPES];		final Map parts = new HashMap();		final Map popup = new HashMap();		for (int i = 0; i < SBar.NUMBER_OF_TYPES; i++) {			bars[i] = new HashMap();		}		final Iterator elementItr = menuElements.iterator();		while (elementItr.hasNext()) {			final MenuElement element = (MenuElement) elementItr.next();			try {				final SLocation[] locations = element.getLocations();				for (int i = 0; i < locations.length; i++) {					final SLocation location = locations[i];					final LocationElement locationElement = location.getPath();					if (locationElement instanceof SBar) {						final SBar bar = (SBar) locationElement;						final int type = bar.getType();						final Map barMap = bars[type];						final String path = bar.getPath();						insertPathIntoMap(path, barMap);					} else if (locationElement instanceof SPopup) {						// TODO Wheeee					} else if (locationElement instanceof SPart) {						// TODO Gotta go to dinner.					}				}			} catch (final NotDefinedException e) {				// This menu element is not defined. Just skip it.			}		}		return new SMenuLayout(bars, parts, popup);	}	private static final void insertPathIntoMap(final String path, final Map map) {		// TODO Implement	}	private final Map[] bars;	private final Map parts;	private final Map popup;	/**	 * Constructs a new instance of <code>SMenuLayout</code>.	 */	SMenuLayout(final Map[] bars, final Map parts, final Map popup) {		this.bars = bars;		this.parts = parts;		this.popup = popup;	}}