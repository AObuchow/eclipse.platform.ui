/******************************************************************************* * Copyright (c) 2006 IBM Corporation and others. * All rights reserved. This program and the accompanying materials * are made available under the terms of the Eclipse Public License v1.0 * which accompanies this distribution, and is available at * http://www.eclipse.org/legal/epl-v10.html * * Contributors: *     IBM Corporation - initial API and implementation ******************************************************************************/package org.eclipse.jface.menus;import java.util.Collection;import java.util.HashMap;import java.util.Iterator;import java.util.Map;import java.util.StringTokenizer;import org.eclipse.core.commands.common.NotDefinedException;/** * <p> * The layout of various menu elements. A layout includes all menus, groups, * items and widgets -- regardless of whether they are currently visible. * </p> * <p> * There are three basic types of menu elements: part, popup and bar. Each of * these fundamental types has a map of subelements -- indexed by some string. * </p> * <p> * Clients may instantiate, but must not extend. * </p> * <p> * <strong>EXPERIMENTAL</strong>. This class or interface has been added as * part of a work in progress. There is a guarantee neither that this API will * work nor that it will remain the same. Please do not use this API without * consulting with the Platform/UI team. * </p> *  * @since 3.2 */public final class SMenuLayout {	/**	 * A node within a menu layout. A node has contains a menu element and some	 * child nodes.	 */	private static final class Node {		/**		 * The children of this node indexed by their identifiers. This map is		 * never <code>null</code>		 */		private final Map childrenById;		/**		 * The element this node represents. This value may be <code>null</code>		 * iff this is a top-level node in some menu layout structure.		 */		private MenuElement element;		/**		 * The identifiers of the children, but in the order indicating by their		 * ordering constraints. This list is lazily generated. TODO This isn't		 * needed yet.		 */		// private List orderedChildIds;		/**		 * Constructs a new <code>SMenuLayout</code>.		 */		private Node() {			childrenById = new HashMap(11);		}		/**		 * Retrieves the child node with the given identifier. If no such node		 * exists yet, it is created.		 * 		 * @param id		 *            The identifier of the child node to retrieve; must not be		 *            <code>null</code>.		 * @return The child node; never <code>null</code>.		 */		private final Node getChildNode(final String id) {			if (id == null) {				throw new NullPointerException(						"A child node cannot have a null identifier"); //$NON-NLS-1$			}			Node childNode = (Node) childrenById.get(id);			if (childNode == null) {				childNode = new Node();				childrenById.put(id, childNode);			}			return childNode;		}		/**		 * Returns the children of this node, if any.		 * 		 * @return The children; never <code>null</code>, but may be empty.		 */		private final Collection getChildren() {			return childrenById.values();		}		/**		 * Returns the menu element for this node.		 * 		 * @return The menu element; may be <code>null</code>.		 */		private final MenuElement getMenuElement() {			return element;		}		/**		 * Sets the menu element for this node.		 * 		 * @param element		 *            The element to set; must not be <code>null</code>.		 */		private final void setElement(final MenuElement element) {			if (element == null) {				throw new NullPointerException(						"A node cannot be given a null element"); //$NON-NLS-1$			}			this.element = element;		}	}	/**	 * <p>	 * Each character in this string represents a path delimiter that is	 * understood by this layout class when parsing paths. This can be passed	 * directly to a string tokenizer for parsing, or the first character can be	 * used for programmatically generating paths.	 * </p>	 * <p>	 * The character "<code>/</code>" is guaranteed to be a path delimiter.	 * </p>	 */	public static final String PATH_DELIMITERS = "/"; //$NON-NLS-1$	/**	 * Adds an entry into one of the top-level bars. A bar can be a menu bar, a	 * tool bar, or a status line.	 * 	 * @param element	 *            The element to insert into the node; must not be	 *            <code>null</code>.	 * @param bar	 *            The location in a bar; must not be <code>null</code>.	 * @param barsByType	 *            The bars indexed by type; never <code>null</code>.	 */	private static final void addBarIntoMap(final MenuElement element,			final SBar bar, final Map barsByType) {		final String type = bar.getType();		Node node = (Node) barsByType.get(type);		if (node == null) {			node = new Node();			barsByType.put(type, node);		}		final String path = bar.getPath();		insertElementIntoNode(element, path, node);	}	/**	 * Adds an entry into a part-level menu layout. A part can contain a menu	 * bar or a tool bar.	 * 	 * @param element	 *            The element to insert into the node; must not be	 *            <code>null</code>.	 * @param part	 *            The part indicator; must not be <code>null</code>	 * @param partsById	 *            The parts indexed by identifier or by type; never	 *            <code>null</code>.	 */	private static final void addPartIntoMap(final MenuElement element,			final SPart part, final Map partsById) {		final String partId = part.getPart();		Map partMap = (Map) partsById.get(partId);		if (partMap == null) {			partMap = new HashMap();			partsById.put(partId, partMap);		}		// final LeafLocationElement location = part.getLocation();		// TODO The part layout	}	/**	 * Adds an entry into a popup menu.	 * 	 * @param element	 *            The element to insert into the popup; must not be	 *            <code>null</code>.	 * @param popup	 *            The popup indicator; must not be <code>null</code>.	 * @param popupsById	 *            The popup menus indexed by identifier; never <code>null</code>.	 */	private static final void addPopupIntoMap(final MenuElement element,			final SPopup popup, final Map popupsById) {		final String popupId = popup.getId();		Node node = (Node) popupsById.get(popupId);		if (node == null) {			node = new Node();			popupsById.put(popupId, node);		}		final String path = popup.getPath();		insertElementIntoNode(element, path, node);	}	/**	 * Generates a menu layout based on a collection of menu elements. This	 * layout will take into account ordering constraints.	 * 	 * @param menuElements	 *            The menu elements to be sorted into a menu layout; must not	 *            <code>null</code>.	 * @return The menu layout corresponding to the menu elements; never	 *         <code>null</code>.	 */	static final SMenuLayout computeLayout(final Collection menuElements) {		final Map barsByType = new HashMap();		final Map partsById = new HashMap();		final Map popupById = new HashMap();		final Iterator elementItr = menuElements.iterator();		while (elementItr.hasNext()) {			final MenuElement element = (MenuElement) elementItr.next();			try {				final SLocation[] locations = element.getLocations();				for (int i = 0; i < locations.length; i++) {					final SLocation location = locations[i];					final LocationElement locationElement = location.getPath();					if (locationElement instanceof SBar) {						final SBar bar = (SBar) locationElement;						addBarIntoMap(element, bar, barsByType);					} else if (locationElement instanceof SPopup) {						final SPopup popup = (SPopup) locationElement;						addPopupIntoMap(element, popup, popupById);					} else if (locationElement instanceof SPart) {						final SPart part = (SPart) locationElement;						addPartIntoMap(element, part, partsById);					}				}			} catch (final NotDefinedException e) {				// This menu element is not defined. Just skip it.			}		}		return new SMenuLayout(barsByType, partsById, popupById);	}	/**	 * Inserts a particular path into a map. The layout is represented by a	 * nesting structure of maps.	 * 	 * @param element	 *            The element to insert into the node; must not be	 *            <code>null</code>.	 * @param path	 *            The path to insert; may be <code>null</code>.	 * @param node	 *            The top-level node representing the layout; must not be	 *            <code>null</code>.	 */	private static final void insertElementIntoNode(final MenuElement element,			final String path, Node node) {		if ((path != null) && (path.length() > 0)) {			final StringTokenizer tokenizer = new StringTokenizer(path,					PATH_DELIMITERS);			while (tokenizer.hasMoreTokens()) {				final String token = tokenizer.nextToken();				node = node.getChildNode(token);			}		}		final String elementId = element.getId();		final Node newNode = node.getChildNode(elementId);		newNode.setElement(element);	}	/**	 * The top-level bars for this menu layout, indexed by type ({@link String}).	 * Each bar is represented by a top-level {@link Node} with no menu element.	 */	private final Map barsByType;	/**	 * The menu layouts for the various parts, indexed by identifier and type ({@link String}).	 * TODO Figure out the real structure for this item.	 */	private final Map partsById;	/**	 * The menu layout for the context menus, indexed by the context menu	 * identifiers ({@link String}). Each menu is represented by a top-level	 * {@link Node} with no menu element.	 */	private final Map popupById;	/**	 * Constructs a new instance of <code>SMenuLayout</code>.	 */	SMenuLayout(final Map barsByType, final Map partsById, final Map popupById) {		this.barsByType = barsByType;		this.partsById = partsById;		this.popupById = popupById;	}	/**	 * This is a debugging method for printing node information. The method is	 * recursive.	 * 	 * @param node	 *            The node which should be printed (along with its children) to	 *            the buffer; must not be <code>null</code>	 * @param buffer	 *            The buffer to which to print; must not be <code>null</code>.	 * @param indent	 *            The identation level for the node; must be a whole number.	 */	private final void printNode(final Node node, final StringBuffer buffer,			final int indent) {		final MenuElement element = node.getMenuElement();		for (int i = 0; i < indent; i++) {			buffer.append(' ');		}		buffer.append(element);		buffer.append('\n');		final Collection children = node.getChildren();		final Iterator childItr = children.iterator();		while (childItr.hasNext()) {			final Node childNode = (Node) childItr.next();			printNode(childNode, buffer, indent + 2);		}	}	/**	 * Prints out some debugging information about the entire menu layout. This	 * information is quite large.	 */	public final String toString() {		final StringBuffer buffer = new StringBuffer();		Iterator entryItr;		// Print out the bars.		buffer.append(" ***** TOP-LEVEL BARS ***** \n"); //$NON-NLS-1$		entryItr = barsByType.entrySet().iterator();		while (entryItr.hasNext()) {			final Map.Entry entry = (Map.Entry) entryItr.next();			final String type = (String) entry.getKey();			Node node = (Node) entry.getValue();			buffer.append(type);			buffer.append('\n');			printNode(node, buffer, 2);		}		// Print out the parts.		buffer.append(" ***** PART-SPECIFIC BARS ***** \n"); //$NON-NLS-1$		entryItr = partsById.entrySet().iterator();		while (entryItr.hasNext()) {			final Map.Entry entry = (Map.Entry) entryItr.next();			final String partId = (String) entry.getKey();			buffer.append(partId);			buffer.append('\n');			// TODO Print out part information.		}		// Print out the context menus.		buffer.append(" ***** CONTEXT MENUS ***** \n"); //$NON-NLS-1$		entryItr = popupById.entrySet().iterator();		while (entryItr.hasNext()) {			final Map.Entry entry = (Map.Entry) entryItr.next();			final String id = (String) entry.getKey();			Node node = (Node) entry.getValue();			buffer.append(id);			buffer.append('\n');			printNode(node, buffer, 2);		}		return buffer.toString();	}}